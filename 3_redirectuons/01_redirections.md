# Стандартные дескрипторы файлов и перенаправление потоков

## Введение

В Linux/Unix системах существует три стандартных дескриптора файлов:
- STDIN (0) - стандартный ввод
- STDOUT (1) - стандартный вывод
- STDERR (2) - стандартный вывод ошибок

## Стандартные дескрипторы файлов

### STDIN (0)

```bash
#!/bin/bash

# Чтение из STDIN
read -p "Введите имя: " name
echo "Привет, $name!"

# Перенаправление STDIN из файла
while read line; do
    echo "Строка: $line"
done < input.txt
```

### STDOUT (1)

```bash
#!/bin/bash

# Перенаправление вывода в файл
echo "Это сообщение будет записано в файл" > output.txt

# Добавление вывода в конец файла
echo "Это сообщение будет добавлено в конец файла" >> output.txt

# Перенаправление вывода команды
ls -l > directory_list.txt
```

### STDERR (2)

```bash
#!/bin/bash

# Перенаправление ошибок в файл
ls nonexistent_file 2> errors.txt

# Перенаправление вывода и ошибок в разные файлы
command > output.txt 2> errors.txt

# Перенаправление вывода и ошибок в один файл
command &> all_output.txt
```

## Перенаправление потока ошибок

### Базовое перенаправление ошибок

```bash
#!/bin/bash

# Перенаправление ошибок в /dev/null
command 2> /dev/null

# Перенаправление ошибок в файл
command 2> error.log
```

### Перенаправление потоков ошибок и вывода

```bash
#!/bin/bash

# Перенаправление вывода и ошибок в один файл
command &> output.log

# Перенаправление вывода и ошибок в разные файлы
command > output.log 2> error.log

# Перенаправление вывода и ошибок в один файл (старый способ)
command > output.log 2>&1
```

## Перенаправление вывода в скриптах

### Временное перенаправление вывода

```bash
#!/bin/bash

# Временное перенаправление вывода одной команды
echo "Это сообщение будет перенаправлено" > output.txt

# Временное перенаправление вывода блока команд
{
    echo "Первая строка"
    echo "Вторая строка"
    echo "Третья строка"
} > output.txt
```

### Постоянное перенаправление вывода

```bash
#!/bin/bash

# Перенаправление всего вывода скрипта
exec 1> output.log
exec 2> error.log

echo "Это сообщение пойдет в output.log"
echo "Ошибка!" >&2
```

## Перенаправление ввода в скриптах

```bash
#!/bin/bash

# Перенаправление ввода из файла
while read line; do
    echo "Обработка: $line"
done < input.txt

# Перенаправление ввода с клавиатуры
read -p "Введите данные: " input < /dev/tty
```

## Создание собственного перенаправления вывода

```bash
#!/bin/bash

# Создание файлового дескриптора
exec 3> custom_output.txt

# Использование пользовательского дескриптора
echo "Это сообщение пойдет в custom_output.txt" >&3

# Закрытие дескриптора
exec 3>&-
```

## Создание дескрипторов файлов для ввода данных

```bash
#!/bin/bash

# Создание дескриптора для ввода
exec 3< input.txt

# Чтение из пользовательского дескриптора
read line <&3
echo "Прочитано: $line"

# Закрытие дескриптора
exec 3<&-
```

## Закрытие дескрипторов файлов

```bash
#!/bin/bash

# Открытие дескриптора
exec 3> output.txt

# Использование дескриптора
echo "Сообщение" >&3

# Закрытие дескриптора
exec 3>&-
```

## Получение сведений об открытых дескрипторах

```bash
#!/bin/bash

# Просмотр открытых дескрипторов
ls -l /proc/$$/fd

# Проверка доступности дескриптора
if [ -e /dev/fd/3 ]; then
    echo "Дескриптор 3 открыт"
else
    echo "Дескриптор 3 закрыт"
fi
```

## Подавление вывода

```bash
#!/bin/bash

# Подавление стандартного вывода
command > /dev/null

# Подавление вывода ошибок
command 2> /dev/null

# Подавление всего вывода
command &> /dev/null
```

## Практическое задание

Создайте скрипт `redirections_demo.sh`:

```bash
#!/bin/bash

# 1. Создание тестовых файлов
echo "Тестовые данные" > input.txt
echo "Дополнительные данные" >> input.txt

# 2. Демонстрация перенаправления вывода
echo "=== Перенаправление вывода ==="
echo "Это сообщение пойдет в output.txt" > output.txt
echo "Это сообщение добавится в output.txt" >> output.txt

# 3. Демонстрация перенаправления ошибок
echo -e "\n=== Перенаправление ошибок ==="
ls nonexistent_file 2> errors.txt

# 4. Демонстрация пользовательских дескрипторов
echo -e "\n=== Пользовательские дескрипторы ==="
exec 3> custom.txt
echo "Сообщение через дескриптор 3" >&3
exec 3>&-

# 5. Демонстрация чтения из файла
echo -e "\n=== Чтение из файла ==="
while read line; do
    echo "Прочитано: $line"
done < input.txt

# 6. Демонстрация подавления вывода
echo -e "\n=== Подавление вывода ==="
echo "Это сообщение не будет показано" > /dev/null
```

## Важные моменты

- Всегда закрывайте пользовательские дескрипторы после использования
- Используйте `&>` для перенаправления вывода и ошибок в один файл
- `/dev/null` используется для подавления вывода
- Проверяйте права доступа при работе с файлами
- Используйте `exec` для постоянного перенаправления

## Дополнительные материалы

- [Bash Redirections](https://www.gnu.org/software/bash/manual/bash.html#Redirections)
- [File Descriptors](https://www.gnu.org/software/bash/manual/bash.html#Redirections)

## Вопросы для самопроверки

1. Какие стандартные дескрипторы файлов существуют в bash?
2. Как перенаправить вывод и ошибки в один файл?
3. Как создать пользовательский дескриптор файла?
4. Как подавить вывод команды?
5. Как закрыть пользовательский дескриптор? 